spring:
  datasource:
 #   url:  jdbc:h2:mem:mydb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;INIT=CREATE SCHEMA IF NOT EXISTS seqdb\;SET SCHEMA seqdb
 #   url: jdbc:postgresql://localhost:5532/seqdb
 #   username: postgres
 #   password: postgres
  jpa:
    hibernate:
      naming:
        # Naming strategies specified to allow @Column/@Table name property.
        implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
      use-new-id-generator-mappings: false
  liquibase:
    change-log: classpath:/db/changelog/db.changelog-master.xml
    # on existing database use "schema-change" only
    contexts: schema-change, initial-data
crnk:
  pathPrefix: /api
  domainName: ""
  defaultPageLimit: 20
  maxPageLimit: 1000
  allow-unknown-attributes: true
  # The "include" query-string param is handled by our code and incorporated into the database
  # query, so we don't let Crnk automatically call findOneTarget for each null relation.
  config.lookup.behavior.default: NONE

keycloak:
  enabled: false
  realm: dina
  auth-server-url: http://${KEYCLOAK_HOST_IP}:8080/auth
  ssl-required: none
  resource: seqdb
  public-client: true
  bearer-only: true
  principal-attribute: preferred_username

logging:
  level:
    com.github.tennaito.rsql: ERROR
